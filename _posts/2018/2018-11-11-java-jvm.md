---
layout: post
title: java 虚拟机
category: java
tags: [java]
---



## 运行时数据区域

![](http://io.dbbaxbb.cn/assets/images/2018/java/jvm.png) <br/>

### 程序计数器

记录正在执行的虚拟机字节码指令的地址（如果是正在咨询过的本地方法则为空）

### java虚拟机栈
每个java方法在执行的同时会创建一个栈帧用于存储局部变量表，操作数栈，常量池等引用信息。从方法的调用直至执行完成过程，就对应这一个栈帧在java虚拟机中入栈出栈的过程

![](http://io.dbbaxbb.cn/assets/images/2018/java/jvm2.png) <br/>

可以通过 -Xss这个虚拟机参数来指定每个线程的java虚拟机栈内存的大小

```
java -Xss512M HackTheJava
```
该区域可能抛出以下异常：
* 当线程请求的栈的深度超过最大值，会抛出StackOverflowError 异常
* 栈进行动态扩展时如果无法申请到足够内存，会抛出OutOfMemoryError异常

### 本地方法栈
本地方法栈与虚拟机栈类似，他们之间的区别就是本地方法栈为本地方法服务

本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。


### 堆
所有的对象都在这里分配内存，是垃圾回收的主要区域（GC堆）

现代的垃圾回收算法基本都是采用分代回收算法，其主要是针对不同的对象采用不同的回收算法，可以将堆分成两块：
* 新生代（Young Generation）
* 老年代 (Old Generation)
堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出OutOfMemoryError异常。
可以通过 -Xms 和 -Xms两个虚拟机参数来指定一个程序的内存大小，第一个参数设置初始值，第二个参数设置最大值。
```
java -Xms1M -Xmx2M HackthenJava
```
### 方法区
用于存放已被加载类的信息，常量，静态变量，即时编译器编译后的代码等数据。
和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出OutOfMemoryError异常

对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现

HotSpot虚拟机把它当成永久代来进行垃圾回收，但是很难确定永久代的大小，因为他受到很多因素的影响，并且每次Full GC之后的永久代的大小都会改变，所以经常会抛出OutOfMemoryError异常。
为了更容易管理方法区，从jdk8开始，移除永久代，并把方法区移至元空间，它位于本地方法中，而不是虚拟机内存中

### 运行时常量池
运行时常量池也是方法区中的一部分，Class文件中的常量池（编译器生成的各种字变量和符号引用）会在类加载后被放进这个区域。这样能在一些场景中显著的提高性能，因为避免了在Java堆和Native堆中来回复制数据

### 直接内存
在jdk4中加入了NIO类，他可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里的DirectByteBuffer 对象作为这块内存的引用进行操作。

## 垃圾回收

垃圾收集主要针对堆和方法区进行

程序计数器，虚拟机栈和本地方法区这三个区域属于线程私有的，只存在线程的生命周期内，线程结束后也会自动消失，因此不需要对这三个区域进行垃圾回收

### 判端一个对象是否可被回收

#### 1，引用计数法
给对象添加一个引用计数器，当对象增加一个引用计数器加1，引用失效是减一，引用计数为0是对象可被回收。
两个对象出现循环引用的情况下，此时引用计数器永远不会为0，导致无法对它们进行垃圾回收
正因为循环引用的存在，所以java不使用引用计数法
```
public class ReferenceCountingGC {

    public Object instance = null;

    public static void main(String[] args) {
        ReferenceCountingGC objectA = new ReferenceCountingGC();
        ReferenceCountingGC objectB = new ReferenceCountingGC();
        objectA.instance = objectB;
        objectB.instance = objectA;
    }
}
```

#### 2， 可达性分析算法
通过GC Roots作为起始点搜索，能够达到的对象都是存活的，不可达的对象可被回收.

java虚拟机使用该算法来判断对象是否可被回收，在Java中GC Roots一般包含以下内容：
* 虚拟机栈中局部变量表中引用的对象
* 本地方法中JNI引用的对象
* 方法中类静态属性引用的对象
* 方法区常量引用的对象

 ![](http://io.dbbaxbb.cn/assets/images/2018/java/jvm3.png) <br/>
 
 3 方法区的回收
 因为方法区主要存放的是永久代对象，而永久代对象的回收率比新生代低很多，因为在方法区上进行回收性价比不高
 主要是对常量池的回收和对类的卸载
 
 在大量使用反射，动态代理，CGlib等ByteCode框架，动态生成JSP以及OSGI这类频繁自定义Classloader的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。
 
 类的卸载条件很多，需要满足一下三个条件，并且满足了也不一定会被卸载
 * 该类的所有实例已经被回收，并且堆中不存在该类的任何实例
 * 加载该类的Classloader已经被回收
 * 该类对应得Class没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。
可以通过 -Xnoclassgc 参数来控制是否对类进行卸载
 
 4 finalize()
 finalize类型C++的析构函数，用来关闭外部资源等工作。但是try-finally等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用循序，因此最后不要使用。
 
 当一个对象被回收时，如果需要执行对象finalize()方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用过finalize()自救，后面回收时不会调用finalize()方法。
 
 ## 引用类型
 无论是通过引用计数法来判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判断对象是否可被回收都与引用有关。
 
 java四种不同程度的引用类型
 
 ### 1，强引用
 被强引用关联的对象不会被回收。
 使用new一个新的对象的方式来创建引用。
 
 ```
 Object obj = new Object();
 ```
 ### 2，软引用
 被软引用的对象只有在内存不够的情况下才会被回收
 
 使用SoftReference类来创建软引用
 ```
 Object obj = new Object();
 SoftReference<Object> sf = new SoftReference<Object>(obj);
 obj = null;  // 使对象只被软引用关联
 ```
 ### 3，弱应用
 被弱引用关联的对象一定会被回收，也就是说他只能存活到下一次垃圾回收发生之前
 使用WeakReference类来实现弱引用
 ```
 Object obj = new Object();
 WeakReference<Object> wf = new WeakReference<Object>(obj);
 obj = null;
 ```
 ### 4，虚引用
 
 又称为幽灵引用和幻影引用，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过一个虚引用取得一个对象
 
 为一个对象设置虚引用关联的唯一目的就是在这个对象被回收时得到一个系统通知。
 使用 PhantomReference 来实现虚引用
 ```
 Object obj = new Object();
 PhantomReference<Object> pf = new PhantomReference<Object>(obj);
 obj = null;
 ```
 
 ## 内存分配与回收策略
 
 ### 
 
 
 
 
 

[参考链接](https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md)