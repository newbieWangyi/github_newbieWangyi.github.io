---
layout: post
title: java 虚拟机
category: java
tags: [java]
---



## 运行时数据区域

![](http://io.dbbaxbb.cn/assets/images/2018/java/jvm.png) <br/>

### 程序计数器

记录正在执行的虚拟机字节码指令的地址（如果是正在咨询过的本地方法则为空）

### java虚拟机栈
每个java方法在执行的同时会创建一个栈帧用于存储局部变量表，操作数栈，常量池等引用信息。从方法的调用直至执行完成过程，就对应这一个栈帧在java虚拟机中入栈出栈的过程

![](http://io.dbbaxbb.cn/assets/images/2018/java/jvm2.png) <br/>

可以通过 -Xss这个虚拟机参数来指定每个线程的java虚拟机栈内存的大小

```
java -Xss512M HackTheJava
```
该区域可能抛出以下异常：
* 当线程请求的栈的深度超过最大值，会抛出StackOverflowError 异常
* 栈进行动态扩展时如果无法申请到足够内存，会抛出OutOfMemoryError异常

### 本地方法栈
本地方法栈与虚拟机栈类似，他们之间的区别就是本地方法栈为本地方法服务

本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。


### 堆
所有的对象都在这里分配内存，是垃圾回收的主要区域（GC堆）

现代的垃圾回收算法基本都是采用分代回收算法，其主要是针对不同的对象采用不同的回收算法，可以将堆分成两块：
* 新生代（Young Generation）
* 老年代 (Old Generation)
堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出OutOfMemoryError异常。
可以通过 -Xms 和 -Xms两个虚拟机参数来指定一个程序的内存大小，第一个参数设置初始值，第二个参数设置最大值。
```
java -Xms1M -Xmx2M HackthenJava
```
### 方法区
用于存放已被加载类的信息，常量，静态变量，即时编译器编译后的代码等数据。
和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出OutOfMemoryError异常

对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现

HotSpot虚拟机把它当成永久代来进行垃圾回收，但是很难确定永久代的大小，因为他受到很多因素的影响，并且每次Full GC之后的永久代的大小都会改变，所以经常会抛出OutOfMemoryError异常。
为了更容易管理方法区，从jdk8开始，移除永久代，并把方法区移至元空间，它位于本地方法中，而不是虚拟机内存中

### 运行时常量池
运行时常量池也是方法区中的一部分，Class文件中的常量池（编译器生成的各种字变量和符号引用）会在类加载后被放进这个区域。这样能在一些场景中显著的提高性能，因为避免了在Java堆和Native堆中来回复制数据

### 直接内存
在jdk4中加入了NIO类，他可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里的DirectByteBuffer 对象作为这块内存的引用进行操作。

## 垃圾回收

垃圾收集主要针对堆和方法区进行

程序计数器，虚拟机栈和本地方法区这三个区域属于线程私有的，只存在线程的生命周期内，线程结束后也会自动消失，因此不需要对这三个区域进行垃圾回收

### 判端一个对象是否可被回收

#### 1，引用计数法
给对象添加一个引用计数器，当对象增加一个引用计数器加1，引用失效是减一，引用计数为0是对象可被回收。
两个对象出现循环引用的情况下，此时引用计数器永远不会为0，导致无法对它们进行垃圾回收
正因为循环引用的存在，所以java不使用引用计数法
```
public class ReferenceCountingGC {

    public Object instance = null;

    public static void main(String[] args) {
        ReferenceCountingGC objectA = new ReferenceCountingGC();
        ReferenceCountingGC objectB = new ReferenceCountingGC();
        objectA.instance = objectB;
        objectB.instance = objectA;
    }
}
```

#### 2， 可达性分析算法
通过GC Roots作为起始点搜索，能够达到的对象都是存活的，不可达的对象可被回收

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 



string被声明为final，因此他不可被继承

内部使用char数组存储数据，该数组被声明为final,这意味着value数组初始化之后就不能再引用其它的数组。并且String内部没有改变value数组的方法，因此可以保证String不可变。

```
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
```
### 不可变的好处

#### 1，可以缓存hash值
因为String的hash值经常被使用，例如string用做hashMap的key,不可变的特性使得hash也不可变，因此只需要进行一次计算

#### 2，String Pool的需要
如果一个String对象已经被创建过了，那么就会从String Pool中取得引用。只有String 是不可变的，才能使用String Pool
![](http://io.dbbaxbb.cn/assets/images/2018/java/1.png) <br/>
#### 3, 安全性
String经常作为参数，String不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果String是可变的，那么在网络连接过程中，String被改变，
改变String对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。

#### 4, 线程安全
String不可变性天生具备线程安全，可以在多线程中安全的使用。

### String,StringBuffer 和StringBuilder

#### 1,可变性
* String不可变
* StringBuffer 和 StringBuilder

#### 2,线程安全
* String 不可变，因此是线程安全的
* StringBuilder 不是线程安全的
* StringBuffer 是线程安全的，内部使用 synchronized 进行同步

### String Pool
字符串常量池，保存着所有的字符串字面量，这些字面量在编译时期就确定，不仅如此，还可以使用String的intern()方法在运行过程中将字符串添加到常量池中。

当一个字符串调用intern()方法时，如果String Pool中已经存在一个字符串和改字符串相等时，那么就会返回String Pool中字符串的引用；否则就会在String Pool中添加一个新的字符串，并返回这个字符串的引用。

下面示例中，s1和s2采用new String()的方式新建两个不同的字符串，而S3好S4是用过s1.intern()方法取得一个字符串的引用。intern()首先把s1引用的字符串放到String Poll中，然后返回这个字符串的引用。因此S3和S4是同一个字符串
``` 
String s1 = new String("aaa");
String s2 = new String("aaa");
System.out.println(s1 == s2);           // false
String s3 = s1.intern();
String s4 = s1.intern();
System.out.println(s3 == s4);           // true
``` 
如果是采用“bbb”这种字面量的形式创建字符串，会自动将字符串放到String Pool中。
```
String s5 = "bbb";
String s6 = "bbb";
System.out.println(s5 == s6);  // true
```

在java 7之前，String Pool被放在运行时常量池中，它属于永久代，而在java7之后，String Pool被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致OutOfMemoryError 错误。

### new String("abc")
使用这种方式一共创建的两个字符串对象（前提是String Pool中还没有'abc'字符串对象）
* “abc”属于字符串字面量，因此在编译时会在String Pool中创建一个字符串对象，指向这个“abc”的字符串面量
* 而使用new的方式会在堆中创建一个字符串对象

创建一个测试类，其main方法中使用这种方式来创建对象
```
public class NewStringTest {
    public static void main(String[] args) {
        String s = new String("abc");
    }
}
```
使用javap -verbose 进行反编译，得到以下内容
```
// ...
Constant pool:
// ...
   #2 = Class              #18            // java/lang/String
   #3 = String             #19            // abc
// ...
  #18 = Utf8               java/lang/String
  #19 = Utf8               abc
// ...

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=3, locals=2, args_size=1
         0: new           #2                  // class java/lang/String
         3: dup
         4: ldc           #3                  // String abc
         6: invokespecial #4                  // Method java/lang/String."<init>":(Ljava/lang/String;)V
         9: astore_1
// ...
```
在 Constant Pool 中，#19 存储这字符串字面量 "abc"，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。

以下是String构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对像的构造函数参数时，并不会完全复制value数组的内容，而是都会指向同一个value数组
```

public String(String original) {
    this.value = original.value;
    this.hash = original.hash;
}
```
[参考链接](https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md)